

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>I am CHP</title>
  <subtitle>This is chp's blog!</subtitle>
  <updated>2024-08-23T13:13:06+08:00</updated>
  <author>
    <name>chp</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 chp </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>docker入门</title>
    <link href="http://localhost:4000/posts/docker%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="docker入门" />
    <published>2024-08-23T13:05:12+08:00</published>
  
    <updated>2024-08-23T13:05:12+08:00</updated>
  
    <id>http://localhost:4000/posts/docker%E5%85%A5%E9%97%A8/</id>
    <content src="http://localhost:4000/posts/docker%E5%85%A5%E9%97%A8/" />
    <author>
      <name>chp</name>
    </author>

  
    
    <category term="Docker" />
    
  

  <summary>docker常用命令

docker images # 显示所有容器镜像
docker ps -all # 列出所有的docker容器（所有状态）
docker pull # 拉取镜像
docker start|stop # 启动或者停止镜像
docker rm docker_name # 删除容器
docker rmi image_name # 删除镜像
docker logs -f docker_name # 查看docker容器日志
docker run --name container_name image_name # 通过镜像启动容器，并为容器命名
docker run -i -t -d -P -p -e key=value docker_name image command # -t 在新容器内制定一个伪终端或终端 -i 允许你对容器内的标准输入进行交互 -d 后台模型...</summary>

  </entry>

  
  <entry>
    <title>常用shell命令</title>
    <link href="http://localhost:4000/posts/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="常用shell命令" />
    <published>2024-08-22T15:21:12+08:00</published>
  
    <updated>2024-08-22T15:21:12+08:00</updated>
  
    <id>http://localhost:4000/posts/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4/</id>
    <content src="http://localhost:4000/posts/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4/" />
    <author>
      <name>chp</name>
    </author>

  
    
    <category term="Shell" />
    
  

  <summary>curl命令

curl 是一个用于在命令行中进行数据传输的工具，支持多种协议（如 HTTP、HTTPS、FTP 等）。它广泛用于测试和调试网络连接、下载文件、与 API 交互等。以下是一些常见的 curl 命令示例和用法：

curl https://example.com # get方式请求数据
curl -X post --data &amp;#39;param=value&amp;#39; https://example.com/ # post方式请求数据
curl -X post -H &amp;quot;Content-Type:application/json&amp;quot; -d &amp;#39;{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;}&amp;#39; http://example.com # json 方式请求数据


ls命令

ls 用于展示文件夹中的内容

ls # List files 
ls -l # list file...</summary>

  </entry>

  
  <entry>
    <title>代理和反向代理</title>
    <link href="http://localhost:4000/posts/proxy/" rel="alternate" type="text/html" title="代理和反向代理" />
    <published>2024-08-22T15:21:12+08:00</published>
  
    <updated>2024-08-22T15:21:12+08:00</updated>
  
    <id>http://localhost:4000/posts/proxy/</id>
    <content src="http://localhost:4000/posts/proxy/" />
    <author>
      <name>chp</name>
    </author>

  
    
    <category term="nginx" />
    
  

  <summary>代理（Proxy）

代理服务器是一个中间服务器，它位于客户端和目标服务器之间，代表客户端向目标服务器发送请求，并将目标服务器的响应返回给客户端。代理服务器的主要功能包括：


  隐私保护：代理服务器可以隐藏客户端的真实 IP 地址，从而保护用户隐私。
  访问控制：代理服务器可以限制用户访问某些网站或资源。
  缓存：代理服务器可以缓存常用资源，从而加快访问速度并减少带宽消耗。
  内容过滤：代理服务器可以过滤不良内容或广告。


假设你在浏览器中访问一个网站，浏览器的请求首先发送到代理服务器，代理服务器再将请求转发给目标网站。目标网站的响应返回给代理服务器，代理服务器再将响应转发给浏览器。

反向代理（Reverse Proxy）

反向代理服务器也是一个中间服务器，但它位于目标服务器和客户端之间，代表目标服务器接收客户端的请求，并将请求转发给目标服务器。反向代理服务器的主要功...</summary>

  </entry>

  
  <entry>
    <title>Chapter5-深入Kafka</title>
    <link href="http://localhost:4000/posts/Kafka_chpater2kafka_chapter5/" rel="alternate" type="text/html" title="Chapter5-深入Kafka" />
    <published>2024-07-29T20:15:12+08:00</published>
  
    <updated>2024-07-29T20:21:01+08:00</updated>
  
    <id>http://localhost:4000/posts/Kafka_chpater2kafka_chapter5/</id>
    <content src="http://localhost:4000/posts/Kafka_chpater2kafka_chapter5/" />
    <author>
      <name>chp</name>
    </author>

  
    
    <category term="Kafka" />
    
  

  <summary>深入Kafka

控制器

控制器其实就是一个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区首领的选举。集群里第一个启动的 broker 通过在Zookeeper 里创建一个临时节点 /controller 让自己成为控制器。其他 broker 在启动时也会尝试创建这个节点，不过它们会收到一个“节点已存在”的异常，然后“意识”到控制器节点已存在，也就是说集群里已经有一个控制器了。

复制

Kafka 使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。那些副本被保存在 broker 上，每个 broker 可以保存成百上千个属于不同主题和分区的副本。


  首领副本（leader）：每个分区都有一个首领副本。为了保证一致性，所有生产者请求和消费者请求都会经过这个副本。
  跟随者副本（follower）：首领以外的副本都是跟随者副本。跟随...</summary>

  </entry>

  
  <entry>
    <title>Chapter4-消费者</title>
    <link href="http://localhost:4000/posts/Kafka_chpater2kafka_chapter4/" rel="alternate" type="text/html" title="Chapter4-消费者" />
    <published>2024-07-29T20:15:12+08:00</published>
  
    <updated>2024-07-29T20:21:01+08:00</updated>
  
    <id>http://localhost:4000/posts/Kafka_chpater2kafka_chapter4/</id>
    <content src="http://localhost:4000/posts/Kafka_chpater2kafka_chapter4/" />
    <author>
      <name>chp</name>
    </author>

  
    
    <category term="Kafka" />
    
  

  <summary>应用程序使用 KafkaConsumer 向 Kafka 订阅主题，并从订阅的主题上接收消息。

Kafka消费者

通过横向伸缩提升消费者的消费能力

Kafka 消费者从属于消费者群组。一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。往群组里增加消费者是横向伸缩消费能力的主要方式。Kafka 消费者经常会做一些高延迟的操作，比如把数据写到数据库或 HDFS，或者使用数据进行比较耗时的计算。在这些情况下，单个消费者无法跟上数据生成的速度，所以可以增加更多的消费者，让它们分担负载，每个消费者只处理部分分区的消息，这就是横向伸缩的主要手段。我们有必要为主题创建大量的分区，在负载增长时可以加入更多的消费者。不过要注意，不要让消费者的数量超过主题分区的数量，多余的消费者只会被闲置。第 2 章介绍了如何为主题选择合适的分区数量。

消费者群组和分区再均衡


  一...</summary>

  </entry>

</feed>


